{"version":3,"sources":["wizmetria_web/processing_simple.cljs"],"mappings":"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","names":["wizmetria-web.processing-simple/extract-words","text","min-length","clojure.string/replace","clojure.string/trim","clojure.string/upper-case","clojure.string.split","p1__12675#","cljs.core.filter","cljs.core/count","cljs.core.into","re-frame.core/reg-fx","p__12677","map__12678","cljs.core/--destructure-map","cljs.core.get","chunk-index","chunk-size","total-length","start-idx","end-idx","x__5090__auto__","y__5091__auto__","finished?","progress","js/console.log","Math/ceil","words","unique-words","p1__12676#","_","re-frame.core/dispatch","js/setTimeout","mirror-sym-words","wizmetria-web.sym/symmetric-word?","mirror-by-axis","cljs.core/group-by","wizmetria-web.sym/axis-id-for-word","rotation-sym-words","word","wizmetria-web.sym/rotation-symmetric-word?","cljs.core/not","total-words","mirror-count","rotation-count","mirror-by-axis-sorted","cljs.core.map","p__12679","vec__12680","cljs.core.nth","axis","cljs.core.sort_by","cljs.core.comp","cljs.core/-","rotation-sorted","stats","cljs.core.take","re-frame.core/dispatch-sync","re_frame.core.reg_event_fx","p__12683","p__12684","map__12685","vec__12686","__","params","p__12689","p__12690","map__12691","vec__12692","db","chunks","cljs.core.partition_all","total-chunks","cljs.core.assoc"],"sourcesContent":["(ns wizmetria-web.processing-simple\r\n  (:require [re-frame.core :as rf]\r\n            [clojure.string :as str]\r\n            [wizmetria-web.sym :as sym]))\r\n\r\n;; -- Simple processing functions --\r\n\r\n(defn extract-words \r\n  \"Extract words from text, filtering by minimum length\"\r\n  [text min-length]\r\n  (-> text\r\n      (str/replace #\"[^a-zA-Z\\s]\" \" \")\r\n      (str/replace #\"\\s+\" \" \")\r\n      (str/trim)\r\n      (str/upper-case)\r\n      (str/split #\"\\s+\")\r\n      (->> (filter #(>= (count %) min-length))\r\n           (into #{}))))\r\n\r\n;; -- Simplified process-chunk function --\r\n(rf/reg-fx\r\n :process-chunk-simple\r\n (fn [{:keys [text chunk-index chunk-size total-length]}]\r\n   (let [start-idx (* chunk-index chunk-size)\r\n         end-idx (min (+ start-idx chunk-size) total-length)\r\n         finished? (>= end-idx total-length)\r\n         progress (/ end-idx total-length)]\r\n     \r\n     (js/console.log \"Processing chunk\" chunk-index \"of\" (Math/ceil (/ total-length chunk-size)))\r\n     \r\n     (if finished?\r\n       ;; If finished, process the entire text at once\r\n       (let [words (-> text\r\n                      (str/replace #\"[^a-zA-Z\\s]\" \" \")\r\n                      (str/replace #\"\\s+\" \" \")\r\n                      (str/trim)\r\n                      (str/upper-case)\r\n                      (str/split #\"\\s+\"))\r\n             unique-words (into #{} (filter #(>= (count %) 3) words))\r\n             \r\n             ;; Update UI that we're finding symmetry\r\n             _ (rf/dispatch [:update-processing-progress \r\n                            {:status :finding-symmetry\r\n                             :progress 100\r\n                             :word-count (count unique-words)}])\r\n             \r\n             ;; Find words with symmetry (time-consuming part)\r\n             _ (js/setTimeout \r\n                #(do\r\n                   ;; Find mirror symmetry words\r\n                   (rf/dispatch [:update-processing-progress \r\n                                {:status :mirror-symmetry\r\n                                 :progress 0}])\r\n                   \r\n                   (let [mirror-sym-words (filter sym/symmetric-word? unique-words)\r\n                         mirror-by-axis (group-by sym/axis-id-for-word mirror-sym-words)\r\n                         \r\n                         _ (rf/dispatch [:update-processing-progress \r\n                                        {:status :rotational-symmetry\r\n                                         :progress 50}])\r\n                         \r\n                         ;; Find rotational symmetry words\r\n                         rotation-sym-words (filter (fn [word] \r\n                                                   (and (sym/rotation-symmetric-word? word)\r\n                                                        (not (sym/symmetric-word? word))))\r\n                                                 unique-words)\r\n                         \r\n                         ;; Prepare stats\r\n                         total-words (count unique-words)\r\n                         mirror-count (count mirror-sym-words)\r\n                         rotation-count (count rotation-sym-words)\r\n                         \r\n                         ;; Sort by length for each axis\r\n                         mirror-by-axis-sorted (into {} \r\n                                                  (map (fn [[axis words]]\r\n                                                         [axis (sort-by (comp - count) words)])\r\n                                                       mirror-by-axis))\r\n                         rotation-sorted (sort-by (comp - count) rotation-sym-words)\r\n                         \r\n                         stats {:total-words total-words\r\n                                :mirror {:count mirror-count\r\n                                         :by-axis mirror-by-axis-sorted\r\n                                         :top-n (take 10 (sort-by (comp - count) mirror-sym-words))}\r\n                                :rotation {:count rotation-count\r\n                                          :words rotation-sorted\r\n                                          :top-n (take 10 rotation-sorted)}}]\r\n                     \r\n                     (rf/dispatch [:update-processing-progress \r\n                                  {:status :done\r\n                                   :progress 100}])\r\n                     (rf/dispatch [:set-wordlist-stats stats])))\r\n                30) ;; Short delay for UI to update\r\n             ]\r\n         nil) ;; No immediate return, async processing\r\n       \r\n       ;; Process the next chunk\r\n       (do\r\n         (rf/dispatch [:update-processing-progress \r\n                      {:status :processing\r\n                       :processed-chunks (inc chunk-index)\r\n                       :progress (* 100 progress)}])\r\n         (js/setTimeout \r\n          #(rf/dispatch-sync [:process-next-chunk-simple \r\n                             {:text text\r\n                              :chunk-index (inc chunk-index)\r\n                              :chunk-size chunk-size\r\n                              :total-length total-length}])\r\n          30)))) ;; Slightly longer delay to keep UI responsive\r\n   nil))\r\n\r\n;; -- New event for simplified processing --\r\n(rf/reg-event-fx\r\n :process-next-chunk-simple\r\n (fn [{:keys [__]} [_ params]]\r\n   {:fx [[:process-chunk-simple params]]}))\r\n\r\n;; -- New event to prepare text using simplified method --\r\n(rf/reg-event-fx\r\n :prepare-text-processing-simple\r\n (fn [{:keys [db]} [_ text]]\r\n   (let [chunks (partition-all 5000 text)\r\n         total-chunks (count chunks)]\r\n     {:db (assoc db :processing-state \r\n                {:status :processing\r\n                 :total-chunks total-chunks\r\n                 :processed-chunks 0\r\n                 :progress 0})\r\n      :fx [[:process-chunk-simple {:text text\r\n                                  :chunk-index 0\r\n                                  :chunk-size 5000\r\n                                  :total-length (count text)}]]}))) "]}